{"version":3,"sources":["flo-lines-intersections.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloLinesIntersections","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","./lib/modified-bentley-ottmann.js","2","ListNode","list","item","prev","next","LinkedList","items","head","undefined","tail","addAllFromScratch","isEmpty","insert","prev_","node","insertInFront","insertAtBack","removeFromFront","removeFromBack","remove","find","removeNode","getAsArray","nodes","push","forEach","prevNode","3","ignoreIntersectionIfEndpointsCoincide","l1","l2","_l","_slicedToArray","p1","p2","_l2","p3","p4","modifiedBentleyOttmann","ls","ignoreIntersectionFunc","events","ol","orient","Event","sort","compare","activeLines","intersections","_i","event","_l3","type","EVENT_LEFT","activeLine","p","segSegIntersection","DELTA","EVENT_RIGHT","_l4","_l5","_l5$","x0","y0","_l5$2","x1","y1","sliceIterator","arr","_arr","_n","_d","_e","_s","Symbol","iterator","done","value","err","Array","isArray","Object","TypeError","b","pA","pB","res","deltaCompare","x","Math","abs","./linked-list.js","./seg-seg-intersection.js","4","ab","cd","delta","_ab","_cd","c","d","denom","rNumer","sNumer"],"mappings":"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","file":"flo-lines-intersections.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloLinesIntersections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar FloLinesIntersections = require('./lib/modified-bentley-ottmann.js');\n\nmodule.exports = exports = FloLinesIntersections;\n\n},{\"./lib/modified-bentley-ottmann.js\":3}],2:[function(require,module,exports){\n'use strict';\n\n/**\r\n * Representation of a linked list node.\r\n *\r\n * @ignore\r\n * @constructor\r\n * @param {LinkedList} list - The linked list this node belongs to.\r\n * @param {*} item - The actual data stored at a node.\r\n * @param {ListNode} prev - The previous item or undefined if there is \r\n * none.\r\n * @param {ListNode} next - The next item or undefined if there is none.\r\n */\n\nfunction ListNode(list, item, prev, next) {\n\tthis.list = list;\n\tthis.item = item;\n\tthis.prev = prev;\n\tthis.next = next;\n}\n\n/**\r\n * Represents a two-way linked list.\r\n * @ignore \r\n * @constructor \r\n */\nfunction LinkedList(items) {\n\tthis.head = undefined;\n\tthis.tail = undefined;\n\n\tif (!items || !items.length) {\n\t\treturn;\n\t}\n\n\taddAllFromScratch(this, items);\n}\n\nLinkedList.isEmpty = function (list) {\n\treturn !list.head;\n};\n\n/**\r\n * Insert an item.\r\n * \r\n * @ignore\r\n * @param item {*} - Item to insert.\r\n * @param prev_ - Insert new item right after this item or if undefined\r\n * insert it in the front.\r\n */\nLinkedList.insert = function (list, item, prev_) {\n\n\tvar node = new ListNode(list, item, undefined, undefined);\n\n\tif (!list.head) {\n\t\t// List is empty\n\t\tlist.head = node;\n\t\tlist.tail = node;\n\t\treturn node;\n\t}\n\n\tvar prev = void 0;\n\tvar next = void 0;\n\tif (!prev_) {\n\t\tnext = list.head;\n\t\tlist.head = node;\n\t} else {\n\t\tprev = prev_;\n\t\tnext = prev_.next;\n\t}\n\n\tif (next) {\n\t\tnext.prev = node;\n\t} else {\n\t\tlist.tail = node;\n\t}\n\tif (prev) {\n\t\tprev.next = node;\n\t}\n\tnode.prev = prev;\n\tnode.next = next;\n\n\treturn node;\n};\n\nLinkedList.insertInFront = function (list, item) {\n\tLinkedList.insert(list, item, undefined);\n};\n\nLinkedList.insertAtBack = function (list, item) {\n\tvar tail = list.tail;\n\n\tvar node = new ListNode(list, item, tail, undefined);\n\n\tif (!tail) {\n\t\tlist.head = node;\n\t\tlist.tail = node;\n\t\treturn;\n\t}\n\n\ttail.next = node;\n\tlist.tail = node;\n};\n\nLinkedList.removeFromFront = function (list, item) {\n\t// TODO - finish\n};\n\nLinkedList.removeFromBack = function (list) {\n\tvar tail = list.tail;\n\tif (!tail) {\n\t\treturn;\n\t}\n\n\tvar prev = tail.prev;\n\tif (!prev) {\n\t\t// List is now empty.\n\t\tlist.head = undefined;\n\t\tlist.tail = undefined;\n\n\t\treturn;\n\t}\n\n\tprev.next = undefined;\n\tlist.tail = prev;\n};\n\nLinkedList.remove = function (list, item) {\n\tvar node = LinkedList.find(list, item);\n\n\tif (!node) {\n\t\treturn;\n\t}\n\n\tLinkedList.removeNode(list, node);\n};\n\nLinkedList.removeNode = function (list, node) {\n\tvar prev = node.prev;\n\tvar next = node.next;\n\n\tif (prev) {\n\t\tif (next) {\n\t\t\tprev.next = next;\n\t\t\tnext.prev = prev;\n\t\t\treturn;\n\t\t}\n\t\tprev.next = undefined;\n\t\tlist.tail = prev;\n\t\treturn;\n\t}\n\n\tif (next) {\n\t\tnext.prev = undefined;\n\t\tlist.head = next;\n\t\treturn;\n\t}\n\n\t// Delete the only item.\n\tlist.head = undefined;\n\tlist.tail = undefined;\n};\n\n/**\r\n * Find a node in the list by === on node.item.\r\n * @ignore\r\n * @returns The found node.\r\n */\nLinkedList.find = function (list, item) {\n\tvar head = list.head;\n\n\tif (!head) {\n\t\treturn undefined;\n\t}\n\n\tvar node = head;\n\twhile (node) {\n\t\tif (node.item === item) {\n\t\t\treturn node;\n\t\t}\n\t\tnode = node.next;\n\t}\n\n\treturn undefined;\n};\n\nLinkedList.getAsArray = function (list) {\n\tvar nodes = [];\n\n\tvar node = list.head;\n\tdo {\n\t\tnodes.push(node.item);\n\n\t\tnode = node.next;\n\t} while (node);\n\n\treturn nodes;\n};\n\nLinkedList.forEach = function (list, f) {\n\tvar node = list.head;\n\tdo {\n\t\tf(node);\n\n\t\tnode = node.next;\n\t} while (node);\n};\n\nLinkedList.addAllFromScratch = function (list, items) {\n\n\tvar prevNode = void 0;\n\tfor (var i = 0; i < items.length; i++) {\n\n\t\tvar node = new ListNode(list, items[i], prevNode, undefined);\n\n\t\tif (prevNode) {\n\t\t\tprevNode.next = node;\n\t\t}\n\t\tprevNode = node;\n\n\t\tif (i === 0) {\n\t\t\tlist.head = node;\n\t\t}\n\t}\n};\n\nmodule.exports = LinkedList;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar LinkedList = require('./linked-list.js');\nvar segSegIntersection = require('./seg-seg-intersection.js');\n\n// The slope tolerance at which two lines are considered either parallel \n// or colinear\nvar DELTA = 1e-10;\n\nvar EVENT_LEFT = 0;\nvar EVENT_RIGHT = 1;\n\n/**\r\n * <p>\r\n * Returns true if the two given lines have an endpoint in common..\r\n * </p>\r\n * <p>\r\n * It is the default function for checking if the intersection between \r\n * two lines should be ignored.\r\n * </p> \r\n * @param {number[][]} l1 - A line.\r\n * @param {number[][]} l2 - Another line.\r\n * @returns {boolean} True if any endpoints between the supplied lines \r\n * coincide, false otherwise.\r\n */\nfunction ignoreIntersectionIfEndpointsCoincide(l1, l2) {\n  var _l = _slicedToArray(l1, 2),\n      p1 = _l[0],\n      p2 = _l[1];\n\n  var _l2 = _slicedToArray(l2, 2),\n      p3 = _l2[0],\n      p4 = _l2[1];\n\n  return p1[0] === p3[0] && p1[1] === p3[1] || p2[0] === p3[0] && p2[1] === p3[1] || p1[0] === p4[0] && p1[1] === p4[1] || p2[0] === p4[0] && p2[1] === p4[1];\n}\n\n/**\r\n * <p>\r\n * Find segment-segment intersections via a very fast modified version  \r\n * of the Bentley-Ottmann algorithm.\r\n * </p>\r\n * <p> \r\n * In practice it almost always runs much much faster than \r\n * Bentley-Ottmann. Even when there are tens of thousands\r\n * of line segments with hundreds of thousands of intersection the  \r\n * Bentley-Ottmann algorithm still do not come close even though it has\r\n * a better asymptotic O((n+k)log-n) run time (where k is the \r\n * number of intersections and n is the number of lines).\r\n * </p>\r\n * <p>\r\n * The algorithm is the same as Bentley-Ottmann except that it replaces\r\n * a binary tree in the implementation with a flat linked list. \r\n * </p>\r\n * <p>\r\n * See http://geomalgorithms.com/a09-_intersect-3.html\r\n * </p>\r\n * @param {number[][][]} ls - An array of lines.\r\n * @param {function} ignoreIntersectionFunc - A function taking 2 lines\r\n * and returns true if the intersection between those two lines should\r\n * be ignored. The default is ignoreIntersectionIfEndpointsCoincide.\r\n * If not supplied (i.e. undefined) no intersections will be ignored.\r\n * @returns {object} An array of objects of the form {p: number[], \r\n * l1: number[][], l2: number[][]} where p is a point of intersection\r\n * and l1 and l2 are the two lines that intersect.\r\n * @example\r\n * modifiedBentleyOttmann([\r\n * \t\t\t[[0,0],     [1,1]], \r\n *\t\t\t[[0,1],     [1,0]],\r\n *\t\t\t[[0.6,1],   [0.7,0.1]],\r\n *\t\t\t[[0,0.4],   [1,0.4]],\r\n *\t\t\t[[0.2,0],   [0.2,1]]\r\n * ]); //=>\r\n */\nfunction modifiedBentleyOttmann(ls, ignoreIntersectionFunc) {\n\n  // Initialize event queue to equal all segment endpoints.\n  var events = [];\n  for (var i = 0; i < ls.length; i++) {\n    var l = ls[i];\n    var ol = orient(l);\n    events.push(new Event(0, l, ol[0]));\n    events.push(new Event(1, l, ol[1]));\n  }\n\n  events.sort(Event.compare);\n\n  var activeLines = new LinkedList();\n\n  var intersections = [];\n  for (var _i = 0; _i < events.length; _i++) {\n    var event = events[_i];\n\n    var _l3 = event.l;\n\n    if (event.type === EVENT_LEFT) {\n\n      if (activeLines.head) {\n        var node = activeLines.head;\n        while (node) {\n          var activeLine = node.item;\n\n          var p = segSegIntersection(_l3, activeLine, DELTA);\n\n          if (!p || ignoreIntersectionFunc && ignoreIntersectionFunc(_l3, activeLine)) {\n            node = node.next;\n            continue;\n          }\n\n          intersections.push({ p: p, l1: _l3, l2: activeLine });\n\n          node = node.next;\n        }\n      }\n\n      LinkedList.insertAtBack(activeLines, _l3);\n    } else if (event.type === EVENT_RIGHT) {\n      var _l4 = event.l;\n\n      LinkedList.remove(activeLines, _l4);\n    }\n  }\n\n  return intersections;\n}\n\n/**\r\n * Returns zero if the two given event points coincide else return > 0 \r\n * if the first point has a greater x coordinate or, if x coordinates \r\n * are equal if the first point's y is greater.\r\n * @ignore\r\n */\nEvent.compare = function (a, b) {\n  var pA = a.p;\n  var pB = b.p;\n\n  var res = deltaCompare(pA[0] - pB[0]);\n  if (res !== 0) {\n    return res;\n  }\n\n  return deltaCompare(pA[1] - pB[1]);\n};\n\nvar deltaCompare = function deltaCompare(x) {\n  return Math.abs(x) < DELTA ? 0 : x;\n};\n\n/**\r\n * Orients the line so that it goes from left to right and if vertical \r\n * from bottom to top.\r\n * \r\n * @ignore \r\n * @param {number[][]} l - A line.\r\n * @returns {number[][]} - An oriented line.\r\n */\nfunction orient(l) {\n  var _l5 = _slicedToArray(l, 2),\n      _l5$ = _slicedToArray(_l5[0], 2),\n      x0 = _l5$[0],\n      y0 = _l5$[1],\n      _l5$2 = _slicedToArray(_l5[1], 2),\n      x1 = _l5$2[0],\n      y1 = _l5$2[1];\n\n  if (x0 < x1) {\n    return l;\n  } else if (x0 > x1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  if (y0 < y1) {\n    return l;\n  } else if (y0 > y1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  return l; // Line has degenerated into a point.\n}\n\n/**\r\n * Event class\r\n * \r\n * @ignore\r\n * @constructor\r\n * @param {number} type - 0 -> left endpoint, 1 -> right endpoint\r\n * @param {number[][]} l - A line.\r\n * @param {number[]} p - A point.\r\n */\nfunction Event(type, l, p) {\n  this.type = type;\n  this.l = l;\n  this.p = p;\n}\n\nmodule.exports = {\n  modifiedBentleyOttmann: modifiedBentleyOttmann,\n  ignoreIntersectionIfEndpointsCoincide: ignoreIntersectionIfEndpointsCoincide\n};\n\n},{\"./linked-list.js\":2,\"./seg-seg-intersection.js\":4}],4:[function(require,module,exports){\n'use strict';\n\n/**\r\n * <p>\r\n * Finds the point where two line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p> \r\n * @param {number[][]} ab - The first line \r\n * @param {number[][]} cd - The second line\r\n * @param {number} delta - The slope tolerance at which two lines are\r\n * considered either parallel or colinear - defaults to 1e-10 \r\n * @returns {number[]} The point where the two line segments intersect  \r\n * or undefined if they don't or if they intersect at infinitely many \r\n * points. \r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction segSegIntersection(ab, cd, delta) {\n\tif (delta === undefined) {\n\t\tdelta = 1e-10;\n\t}\n\n\tvar _ab = _slicedToArray(ab, 2),\n\t    a = _ab[0],\n\t    b = _ab[1];\n\n\tvar _cd = _slicedToArray(cd, 2),\n\t    c = _cd[0],\n\t    d = _cd[1];\n\n\tvar denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n\n\tvar rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n\tvar sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n\n\tif (Math.abs(denom) <= delta) {\n\t\t// parallel\n\t\tif (Math.abs(rNumer) <= delta) {\n\t\t\t// colinear\n\t\t\t// TODO Check if x-projections and y-projections intersect\n\t\t\t// and return the line of intersection if they do.\n\t\t\treturn undefined;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tvar r = rNumer / denom;\n\tvar s = sNumer / denom;\n\n\tif (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n\t\treturn [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = segSegIntersection;\n\n},{}]},{},[1])(1)\n});"]}