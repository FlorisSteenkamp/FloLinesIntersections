{"version":3,"sources":["flo-lines-intersections.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloLinesIntersections","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","./lib/modified-bentley-ottmann.js","2","ignoreIntersectionIfEndpointsCoincide","l1","l2","_l","_slicedToArray","p1","p2","_l2","p3","p4","modifiedBentleyOttmann","ls","ignoreIntersectionFunc","events","ol","orient","push","Event","sort","compare","activeLines","Set","intersections","_i","event","_l3","type","EVENT_LEFT","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","values","Symbol","iterator","next","done","activeLine","value","p","segSegIntersection","DELTA","err","return","add","EVENT_RIGHT","_l4","delete","_l5","_l5$","x0","y0","_l5$2","x1","y1","sliceIterator","arr","_arr","_n","_d","_e","_s","Array","isArray","Object","TypeError","b","pA","pB","res","./seg-seg-intersection.js","3","ab","cd","delta","_ab","_cd","c","d","denom","rNumer","sNumer","Math","abs"],"mappings":"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","file":"flo-lines-intersections.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloLinesIntersections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar FloLinesIntersections = require('./lib/modified-bentley-ottmann.js');\n\nmodule.exports = exports = FloLinesIntersections;\n\n},{\"./lib/modified-bentley-ottmann.js\":2}],2:[function(require,module,exports){\n'use strict';\n\n//let LinkedList         = require('./linked-list.js');\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar segSegIntersection = require('./seg-seg-intersection.js');\n\n// The slope tolerance at which two lines are considered either parallel \n// or colinear\nvar DELTA = 1e-10;\n\nvar EVENT_LEFT = 0;\nvar EVENT_RIGHT = 1;\n\n/**\r\n * <p>\r\n * Returns true if the two given lines have an endpoint in common..\r\n * </p>\r\n * <p>\r\n * It is the default function for checking if the intersection between \r\n * two lines should be ignored.\r\n * </p> \r\n * @ignore\r\n * @param {number[][]} l1 - A line.\r\n * @param {number[][]} l2 - Another line.\r\n * @returns {boolean} True if any endpoints between the supplied lines \r\n * coincide, false otherwise.\r\n */\nfunction ignoreIntersectionIfEndpointsCoincide(l1, l2) {\n  var _l = _slicedToArray(l1, 2),\n      p1 = _l[0],\n      p2 = _l[1];\n\n  var _l2 = _slicedToArray(l2, 2),\n      p3 = _l2[0],\n      p4 = _l2[1];\n\n  return p1[0] === p3[0] && p1[1] === p3[1] || p2[0] === p3[0] && p2[1] === p3[1] || p1[0] === p4[0] && p1[1] === p4[1] || p2[0] === p4[0] && p2[1] === p4[1];\n}\n\n/**\r\n * <p>\r\n * Find segment-segment intersections via a very fast modified version  \r\n * of the Bentley-Ottmann algorithm.\r\n * </p>\r\n * <p> \r\n * In practice it almost always runs much much faster than \r\n * Bentley-Ottmann. Even when there are tens of thousands\r\n * of line segments with hundreds of thousands of intersection the  \r\n * Bentley-Ottmann algorithm still do not come close even though it has\r\n * a better asymptotic O((n+k)log-n) run time (where k is the \r\n * number of intersections and n is the number of lines).\r\n * </p>\r\n * <p>\r\n * The algorithm is the same as Bentley-Ottmann except that it replaces\r\n * a binary tree in the implementation with a flat linked list. \r\n * </p>\r\n * <p>\r\n * See http://geomalgorithms.com/a09-_intersect-3.html\r\n * </p>\r\n * @param {number[][][]} ls - An array of line segments.\r\n * @param {function|boolean} ignoreIntersectionFunc - If set to true\r\n * line segments with coinciding endpoints' intersection will be \r\n * ignored. If falsey, all intersections will be returned. If a function \r\n * is provided (taking as parameters 2 lines and returns true if the \r\n * intersection between those two lines should be ignored) then those\r\n * intersections for which the function returns true will be ignored.\r\n * @returns {object} An array of objects of the form {p: number[], \r\n * l1, l2} where p is a point of intersection and l1 and l2 are the two \r\n * line segments that intersect. Note that l1 and l2 reference the same\r\n * line segment objects passed in to this function. This allows for the\r\n * attachedment of additional properties to the line segment objects\r\n * that won't be lost.\r\n * @example\r\n * modifiedBentleyOttmann([\r\n * \t\t\t[[0,0],     [1,1]], \r\n *\t\t\t[[0,1],     [1,0]],\r\n *\t\t\t[[0.6,1],   [0.7,0.1]],\r\n *\t\t\t[[0,0.4],   [1,0.4]],\r\n *\t\t\t[[0.2,0],   [0.2,1]]\r\n * ]); //=>\r\n */\nfunction modifiedBentleyOttmann(ls, ignoreIntersectionFunc) {\n  if (ignoreIntersectionFunc === true) {\n    ignoreIntersectionFunc = ignoreIntersectionIfEndpointsCoincide;\n  }\n\n  // Initialize event queue to equal all segment endpoints.\n  var events = [];\n  for (var i = 0; i < ls.length; i++) {\n    var l = ls[i];\n    var ol = orient(l);\n    events.push(new Event(0, l, ol[0]));\n    events.push(new Event(1, l, ol[1]));\n  }\n\n  events.sort(Event.compare);\n\n  //let activeLines = new LinkedList();\n  var activeLines = new Set();\n\n  var intersections = [];\n  for (var _i = 0; _i < events.length; _i++) {\n    var event = events[_i];\n\n    var _l3 = event.l;\n\n    if (event.type === EVENT_LEFT) {\n\n      /*\r\n      if (activeLines.head) {\r\n      \tlet node = activeLines.head;\r\n      \twhile (node) {\r\n      \t\tlet activeLine = node.item;\r\n      \t\r\n      \t\tlet p = segSegIntersection(\r\n       \t\t\t\t\t\tl, activeLine, DELTA\r\n       \t\t\t\t);\r\n      \t\t\r\n       \t\t\t\tif (!p || (ignoreIntersectionFunc && \r\n       \t\t\t\t\t\tignoreIntersectionFunc(l,activeLine))) { \r\n       \t\t\t\t\tnode = node.next;\t\t\r\n       \t\t\t\t\tcontinue;\r\n       \t\t\t\t}\r\n       \t\t\t\t\r\n       \t\t\t\tintersections.push({p, l1: l, l2: activeLine });\r\n       \t\t\t\r\n      \t\tnode = node.next;\r\n      \t}\r\n      }\r\n      */\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = activeLines.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var activeLine = _step.value;\n\n          var p = segSegIntersection(_l3, activeLine, DELTA);\n\n          if (!p || ignoreIntersectionFunc && ignoreIntersectionFunc(_l3, activeLine)) {\n            continue;\n          }\n\n          intersections.push({ p: p, l1: _l3, l2: activeLine });\n        }\n\n        //LinkedList.insertAtBack(activeLines, l);\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      activeLines.add(_l3);\n    } else if (event.type === EVENT_RIGHT) {\n      var _l4 = event.l;\n\n      //LinkedList.remove(activeLines, l);\n      activeLines.delete(_l4);\n    }\n  }\n\n  return intersections;\n}\n\n/**\r\n * Returns zero if the two given event points coincide else return > 0 \r\n * if the first point has a greater x coordinate or, if x coordinates \r\n * are equal if the first point's y is greater.\r\n * @ignore\r\n */\n/*\r\nEvent.compare = function(a,b) {\r\n\tlet pA = a.p;\r\n\tlet pB = b.p;\r\n\t\r\n\tlet res = deltaCompare(pA[0] - pB[0]);\r\n\tif (res !== 0) { \r\n\t\treturn res; \r\n\t}\r\n\t\r\n\treturn deltaCompare(pA[1] - pB[1]);\r\n}\r\n*/\nEvent.compare = function (a, b) {\n  var pA = a.p;\n  var pB = b.p;\n\n  var res = pA[0] - pB[0];\n  if (res !== 0) {\n    return res;\n  }\n\n  return pA[1] - pB[1];\n};\n\nvar deltaCompare = function deltaCompare(x) {\n  return Math.abs(x) < DELTA ? 0 : x;\n};\n\n/**\r\n * Orients the line so that it goes from left to right and if vertical \r\n * from bottom to top.\r\n * \r\n * @ignore \r\n * @param {number[][]} l - A line.\r\n * @returns {number[][]} - An oriented line.\r\n */\nfunction orient(l) {\n  var _l5 = _slicedToArray(l, 2),\n      _l5$ = _slicedToArray(_l5[0], 2),\n      x0 = _l5$[0],\n      y0 = _l5$[1],\n      _l5$2 = _slicedToArray(_l5[1], 2),\n      x1 = _l5$2[0],\n      y1 = _l5$2[1];\n\n  if (x0 < x1) {\n    return l;\n  } else if (x0 > x1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  if (y0 < y1) {\n    return l;\n  } else if (y0 > y1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  return l; // Line has degenerated into a point.\n}\n\n/**\r\n * Event class\r\n * \r\n * @ignore\r\n * @constructor\r\n * @param {number} type - 0 -> left endpoint, 1 -> right endpoint\r\n * @param {number[][]} l - A line.\r\n * @param {number[]} p - A point.\r\n */\nfunction Event(type, l, p) {\n  this.type = type;\n  this.l = l;\n  this.p = p;\n}\n\nmodule.exports = modifiedBentleyOttmann;\n\n},{\"./seg-seg-intersection.js\":3}],3:[function(require,module,exports){\n'use strict';\n\n/**\r\n * <p>\r\n * Finds the point where two line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p> \r\n * @param {number[][]} ab - The first line \r\n * @param {number[][]} cd - The second line\r\n * @param {number} delta - The slope tolerance at which two lines are\r\n * considered either parallel or colinear - defaults to 1e-10 \r\n * @returns {number[]} The point where the two line segments intersect  \r\n * or undefined if they don't or if they intersect at infinitely many \r\n * points. \r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction segSegIntersection(ab, cd, delta) {\n\tif (delta === undefined) {\n\t\tdelta = 1e-10;\n\t}\n\n\tvar _ab = _slicedToArray(ab, 2),\n\t    a = _ab[0],\n\t    b = _ab[1];\n\n\tvar _cd = _slicedToArray(cd, 2),\n\t    c = _cd[0],\n\t    d = _cd[1];\n\n\tvar denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n\n\tvar rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n\tvar sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n\n\tif (Math.abs(denom) <= delta) {\n\t\t// parallel\n\t\tif (Math.abs(rNumer) <= delta) {\n\t\t\t// colinear\n\t\t\t// TODO Check if x-projections and y-projections intersect\n\t\t\t// and return the line of intersection if they do.\n\t\t\treturn undefined;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tvar r = rNumer / denom;\n\tvar s = sNumer / denom;\n\n\tif (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n\t\treturn [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = segSegIntersection;\n\n},{}]},{},[1])(1)\n});"]}