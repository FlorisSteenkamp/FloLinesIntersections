{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloLinesIntersections","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","ignoreIntersectionIfEndpointsCoincide","l1","l2","_l","_slicedToArray","p1","p2","_l2","p3","p4","modifiedBentleyOttmann","ls","ignoreIntersectionFunc","events","ol","orient","push","Event","sort","compare","activeLines","Set","intersections","_i","event","_l3","type","EVENT_LEFT","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","values","Symbol","iterator","next","done","activeLine","value","p","segSegIntersection","DELTA","err","return","add","EVENT_RIGHT","_l4","delete","_l5","_l5$","x0","y0","_l5$2","x1","y1","ab","cd","delta","_ab","b","_cd","c","d","denom","rNumer","sNumer","Math","abs","sliceIterator","arr","_arr","_n","_d","_e","_s","Array","isArray","Object","TypeError","pA","pB","res"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloLinesIntersections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\n// The slope tolerance at which two lines are considered either parallel \n// or colinear\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;_e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }return _arr;\n  }return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar DELTA = 1e-10;\n\nvar EVENT_LEFT = 0;\nvar EVENT_RIGHT = 1;\n\n/**\r\n * <p>\r\n * Returns true if the two given lines have an endpoint in common..\r\n * </p>\r\n * <p>\r\n * It is the default function for checking if the intersection between \r\n * two lines should be ignored.\r\n * </p> \r\n * @ignore\r\n * @param {number[][]} l1 - A line.\r\n * @param {number[][]} l2 - Another line.\r\n * @returns {boolean} True if any endpoints between the supplied lines \r\n * coincide, false otherwise.\r\n */\nfunction ignoreIntersectionIfEndpointsCoincide(l1, l2) {\n  var _l = _slicedToArray(l1, 2),\n      p1 = _l[0],\n      p2 = _l[1];\n\n  var _l2 = _slicedToArray(l2, 2),\n      p3 = _l2[0],\n      p4 = _l2[1];\n\n  return p1[0] === p3[0] && p1[1] === p3[1] || p2[0] === p3[0] && p2[1] === p3[1] || p1[0] === p4[0] && p1[1] === p4[1] || p2[0] === p4[0] && p2[1] === p4[1];\n}\n\n/**\r\n * <p>\r\n * Find segment-segment intersections via a very fast modified version  \r\n * of the Bentley-Ottmann algorithm.\r\n * </p>\r\n * <p> \r\n * In practice it almost always runs much much faster than \r\n * Bentley-Ottmann. Even when there are tens of thousands\r\n * of line segments with hundreds of thousands of intersection the  \r\n * Bentley-Ottmann algorithm still do not come close even though it has\r\n * a better asymptotic O((n+k)log-n) run time (where k is the \r\n * number of intersections and n is the number of lines).\r\n * </p>\r\n * <p>\r\n * The algorithm is the same as Bentley-Ottmann except that it replaces\r\n * a binary tree in the implementation with a flat linked list. \r\n * </p>\r\n * <p>\r\n * See http://geomalgorithms.com/a09-_intersect-3.html\r\n * </p>\r\n * @param {number[][][]} ls - An array of line segments.\r\n * @param {function|boolean} ignoreIntersectionFunc - If set to true\r\n * line segments with coinciding endpoints' intersection will be \r\n * ignored. If falsey, all intersections will be returned. If a function \r\n * is provided (taking as parameters 2 lines and returns true if the \r\n * intersection between those two lines should be ignored) then those\r\n * intersections for which the function returns true will be ignored.\r\n * @returns {object} An array of objects of the form {p: number[], \r\n * l1, l2} where p is a point of intersection and l1 and l2 are the two \r\n * line segments that intersect. Note that l1 and l2 reference the same\r\n * line segment objects passed in to this function. This allows for the\r\n * attachedment of additional properties to the line segment objects\r\n * that won't be lost.\r\n * @example\r\n * modifiedBentleyOttmann([\r\n * \t\t\t[[0,0],     [1,1]], \r\n *\t\t\t[[0,1],     [1,0]],\r\n *\t\t\t[[0.6,1],   [0.7,0.1]],\r\n *\t\t\t[[0,0.4],   [1,0.4]],\r\n *\t\t\t[[0.2,0],   [0.2,1]]\r\n * ]); //=>\r\n */\nfunction modifiedBentleyOttmann(ls, ignoreIntersectionFunc) {\n  if (ignoreIntersectionFunc === true) {\n    ignoreIntersectionFunc = ignoreIntersectionIfEndpointsCoincide;\n  }\n\n  // Initialize event queue to equal all segment endpoints.\n  var events = [];\n  for (var i = 0; i < ls.length; i++) {\n    var l = ls[i];\n    var ol = orient(l);\n    events.push(new Event(0, l, ol[0]));\n    events.push(new Event(1, l, ol[1]));\n  }\n\n  events.sort(Event.compare);\n\n  var activeLines = new Set();\n\n  var intersections = [];\n  for (var _i = 0; _i < events.length; _i++) {\n    var event = events[_i];\n\n    var _l3 = event.l;\n\n    if (event.type === EVENT_LEFT) {\n\n      /*\r\n      if (activeLines.head) {\r\n      \tlet node = activeLines.head;\r\n      \twhile (node) {\r\n      \t\tlet activeLine = node.item;\r\n      \t\r\n      \t\tlet p = segSegIntersection(\r\n       \t\t\t\t\t\tl, activeLine, DELTA\r\n       \t\t\t\t);\r\n      \t\t\r\n       \t\t\t\tif (!p || (ignoreIntersectionFunc && \r\n       \t\t\t\t\t\tignoreIntersectionFunc(l,activeLine))) { \r\n       \t\t\t\t\tnode = node.next;\t\t\r\n       \t\t\t\t\tcontinue;\r\n       \t\t\t\t}\r\n       \t\t\t\t\r\n       \t\t\t\tintersections.push({p, l1: l, l2: activeLine });\r\n       \t\t\t\r\n      \t\tnode = node.next;\r\n      \t}\r\n      }\r\n      */\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = activeLines.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var activeLine = _step.value;\n\n          var p = segSegIntersection(_l3, activeLine, DELTA);\n\n          if (!p || ignoreIntersectionFunc && ignoreIntersectionFunc(_l3, activeLine)) {\n            continue;\n          }\n\n          intersections.push({ p: p, l1: _l3, l2: activeLine });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      activeLines.add(_l3);\n    } else if (event.type === EVENT_RIGHT) {\n      var _l4 = event.l;\n\n      activeLines.delete(_l4);\n    }\n  }\n\n  return intersections;\n}\n\nEvent.compare = function (a, b) {\n  var pA = a.p;\n  var pB = b.p;\n\n  var res = pA[0] - pB[0];\n  if (res !== 0) {\n    return res;\n  }\n\n  return pA[1] - pB[1];\n};\n\nvar deltaCompare = function deltaCompare(x) {\n  return Math.abs(x) < DELTA ? 0 : x;\n};\n\n/**\r\n * Orients the line so that it goes from left to right and if vertical \r\n * from bottom to top.\r\n * \r\n * @ignore \r\n * @param {number[][]} l - A line.\r\n * @returns {number[][]} - An oriented line.\r\n */\nfunction orient(l) {\n  var _l5 = _slicedToArray(l, 2),\n      _l5$ = _slicedToArray(_l5[0], 2),\n      x0 = _l5$[0],\n      y0 = _l5$[1],\n      _l5$2 = _slicedToArray(_l5[1], 2),\n      x1 = _l5$2[0],\n      y1 = _l5$2[1];\n\n  if (x0 < x1) {\n    return l;\n  } else if (x0 > x1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  if (y0 < y1) {\n    return l;\n  } else if (y0 > y1) {\n    return [[x1, y1], [x0, y0]];\n  }\n\n  return l; // Line has degenerated into a point.\n}\n\n/**\r\n * Event class\r\n * \r\n * @ignore\r\n * @constructor\r\n * @param {number} type - 0 -> left endpoint, 1 -> right endpoint\r\n * @param {number[][]} l - A line.\r\n * @param {number[]} p - A point.\r\n */\nfunction Event(type, l, p) {\n  this.type = type;\n  this.l = l;\n  this.p = p;\n}\n\n/**\r\n * <p>\r\n * Finds the point where two line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p> \r\n * @param {number[][]} ab - The first line \r\n * @param {number[][]} cd - The second line\r\n * @param {number} delta - The slope tolerance at which two lines are\r\n * considered either parallel or colinear - defaults to 1e-10 \r\n * @returns {number[]} The point where the two line segments intersect  \r\n * or undefined if they don't or if they intersect at infinitely many \r\n * points. \r\n */\nfunction segSegIntersection(ab, cd, delta) {\n  if (delta === undefined) {\n    delta = 1e-10;\n  }\n\n  var _ab = _slicedToArray(ab, 2),\n      a = _ab[0],\n      b = _ab[1];\n\n  var _cd = _slicedToArray(cd, 2),\n      c = _cd[0],\n      d = _cd[1];\n\n  var denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n\n  var rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n  var sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n\n  if (Math.abs(denom) <= delta) {\n    // parallel\n    if (Math.abs(rNumer) <= delta) {\n      // colinear\n      // TODO Check if x-projections and y-projections intersect\n      // and return the line of intersection if they do.\n      return undefined;\n    }\n    return undefined;\n  }\n\n  var r = rNumer / denom;\n  var s = sNumer / denom;\n\n  if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n    return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n  }\n\n  return undefined;\n}\n\nmodule.exports = modifiedBentleyOttmann;\n\n},{}]},{},[1])(1)\n});"]}