{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloLinesIntersections","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","default","./index","2","_classCallCheck","instance","Constructor","TypeError","ignoreIntersectionIfEndpointsCoincide","l1","l2","_l","_slicedToArray","p1","p2","_l2","p3","p4","modifiedBentleyOttmann","ls","ignoreIntersectionFunc","events","ol","orient","push","Event","sort","compare","activeLines","Set","intersections","_i","event","_l3","type","EVENT_LEFT","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","values","Symbol","iterator","next","done","activeLine","value","p","segSegIntersection","DELTA","err","return","add","EVENT_RIGHT","_l4","delete","_l5","_l5$","x0","y0","_l5$2","x1","y1","ab","cd","delta","arguments","_ab","b","_cd","c","d","denom","rNumer","sNumer","Math","abs","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","sliceIterator","arr","_arr","_n","_d","_e","_s","Array","isArray","pA","pB","res"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloLinesIntersections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = _dereq_(\"./index\").default;\n\n},{\"./index\":2}],2:[function(_dereq_,module,exports){\n\"use strict\";\n// The slope tolerance at which two lines are considered either parallel or \n// colinear.\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DELTA = 1e-10;\nvar EVENT_LEFT = 0;\nvar EVENT_RIGHT = 1;\n/**\r\n * Returns true if the two given lines have an endpoint in common..\r\n *\r\n * It is the default function for checking if the intersection between\r\n * two lines should be ignored.\r\n *\r\n * @private\r\n * @param l1 - A line.\r\n * @param l2 - Another line.\r\n * @returns {boolean} True if any endpoints between the supplied lines\r\n * coincide, false otherwise.\r\n */\nfunction ignoreIntersectionIfEndpointsCoincide(l1, l2) {\n    var _l = _slicedToArray(l1, 2),\n        p1 = _l[0],\n        p2 = _l[1];\n\n    var _l2 = _slicedToArray(l2, 2),\n        p3 = _l2[0],\n        p4 = _l2[1];\n\n    return p1[0] === p3[0] && p1[1] === p3[1] || p2[0] === p3[0] && p2[1] === p3[1] || p1[0] === p4[0] && p1[1] === p4[1] || p2[0] === p4[0] && p2[1] === p4[1];\n}\n/**\r\n * Find segment-segment intersections via a very fast modified version of the\r\n * Bentley-Ottmann algorithm.\r\n *\r\n * In practice it almost always runs much much faster than Bentley-Ottmann. Even\r\n * when there are tens of thousands of line segments with hundreds of thousands\r\n * of intersection the Bentley-Ottmann algorithm still do not come close even\r\n * though it has a better asymptotic O((n+k)log-n) run time (where k is the\r\n * number of intersections and n is the number of lines).\r\n *\r\n * The algorithm is the same as Bentley-Ottmann except that it replaces a binary\r\n * tree in the implementation with a flat linked list.\r\n *\r\n * See http://geomalgorithms.com/a09-_intersect-3.html\r\n *\r\n * Returns an array of objects of the form {p: number[], l1, l2} where p is a\r\n * point of intersection and l1 and l2 are the two line segments that intersect.\r\n * Note that l1 and l2 reference the same line segment objects passed in to this\r\n * function. This allows for the attachedment of additional properties to the\r\n * line segment objects that won't be lost.\r\n *\r\n * @param ls - An array of line segments.\r\n * @param ignoreIntersectionFunc - If set to true line segments with coinciding\r\n * endpoints' intersection will be ignored. If falsey, all intersections will be\r\n * returned. If a function is provided (taking as parameters 2 lines and returns\r\n * true if the intersection between those two lines should be ignored) then\r\n * those intersections for which the function returns true will be ignored.\r\n * @example\r\n * modifiedBentleyOttmann([\r\n * \t\t\t[[0,0],     [1,1]],\r\n *\t\t\t[[0,1],     [1,0]],\r\n *\t\t\t[[0.6,1],   [0.7,0.1]],\r\n *\t\t\t[[0,0.4],   [1,0.4]],\r\n *\t\t\t[[0.2,0],   [0.2,1]]\r\n * ]); //=>\r\n */\nfunction modifiedBentleyOttmann(ls, ignoreIntersectionFunc) {\n    if (ignoreIntersectionFunc === true) {\n        ignoreIntersectionFunc = ignoreIntersectionIfEndpointsCoincide;\n    }\n    // Initialize event queue to equal all segment endpoints.\n    var events = [];\n    for (var i = 0; i < ls.length; i++) {\n        var l = ls[i];\n        var ol = orient(l);\n        events.push(new Event(0, l, ol[0]));\n        events.push(new Event(1, l, ol[1]));\n    }\n    events.sort(Event.compare);\n    var activeLines = new Set();\n    var intersections = [];\n    for (var _i = 0; _i < events.length; _i++) {\n        var event = events[_i];\n        var _l3 = event.l;\n        if (event.type === EVENT_LEFT) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = activeLines.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var activeLine = _step.value;\n\n                    var p = segSegIntersection(_l3, activeLine, DELTA);\n                    if (!p || ignoreIntersectionFunc && ignoreIntersectionFunc(_l3, activeLine)) {\n                        continue;\n                    }\n                    intersections.push({ p: p, l1: _l3, l2: activeLine });\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            activeLines.add(_l3);\n        } else if (event.type === EVENT_RIGHT) {\n            var _l4 = event.l;\n            activeLines.delete(_l4);\n        }\n    }\n    return intersections;\n}\nvar deltaCompare = function deltaCompare(x) {\n    return Math.abs(x) < DELTA ? 0 : x;\n};\n/**\r\n * Orients the line so that it goes from left to right and if vertical\r\n * from bottom to top. Returns the oriented line.\r\n *\r\n * @private\r\n * @param l - A line.\r\n */\nfunction orient(l) {\n    var _l5 = _slicedToArray(l, 2),\n        _l5$ = _slicedToArray(_l5[0], 2),\n        x0 = _l5$[0],\n        y0 = _l5$[1],\n        _l5$2 = _slicedToArray(_l5[1], 2),\n        x1 = _l5$2[0],\n        y1 = _l5$2[1];\n\n    if (x0 < x1) {\n        return l;\n    } else if (x0 > x1) {\n        return [[x1, y1], [x0, y0]];\n    }\n    if (y0 < y1) {\n        return l;\n    } else if (y0 > y1) {\n        return [[x1, y1], [x0, y0]];\n    }\n    return l; // Line has degenerated into a point.\n}\n/**\r\n * Event class\r\n *\r\n * @ignore\r\n * @constructor\r\n * @param {number} type - 0 -> left endpoint, 1 -> right endpoint\r\n * @param {number[][]} l - A line.\r\n * @param {number[]} p - A point.\r\n */\n\nvar Event = function () {\n    function Event(type, l, p) {\n        _classCallCheck(this, Event);\n\n        this.type = type;\n        this.l = l;\n        this.p = p;\n    }\n\n    _createClass(Event, null, [{\n        key: \"compare\",\n        value: function compare(a, b) {\n            var pA = a.p;\n            var pB = b.p;\n            var res = pA[0] - pB[0];\n            if (res !== 0) {\n                return res;\n            }\n            return pA[1] - pB[1];\n        }\n    }]);\n\n    return Event;\n}();\n/**\r\n * <p>\r\n * Finds the point where two line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p>\r\n * @param {number[][]} ab - The first line\r\n * @param {number[][]} cd - The second line\r\n * @param {number} delta - The slope tolerance at which two lines are\r\n * considered either parallel or colinear - defaults to 1e-10\r\n * @returns {number[]} The point where the two line segments intersect\r\n * or undefined if they don't or if they intersect at infinitely many\r\n * points.\r\n */\n\n\nfunction segSegIntersection(ab, cd) {\n    var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-10;\n\n    var _ab = _slicedToArray(ab, 2),\n        a = _ab[0],\n        b = _ab[1];\n\n    var _cd = _slicedToArray(cd, 2),\n        c = _cd[0],\n        d = _cd[1];\n\n    var denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n    var rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n    var sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n    if (Math.abs(denom) <= delta) {\n        // parallel\n        if (Math.abs(rNumer) <= delta) {\n            // colinear\n            // TODO Check if x-projections and y-projections intersect\n            // and return the line of intersection if they do.\n            return undefined;\n        }\n        return undefined;\n    }\n    var r = rNumer / denom;\n    var s = sNumer / denom;\n    if (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n        return [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n    }\n    return undefined;\n}\nexports.default = modifiedBentleyOttmann;\n\n},{}]},{},[1])(1)\n});"]}